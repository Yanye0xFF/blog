<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ggl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ggl.h</h1><a href="ggl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//&amp; ****************************************************************************</span>
00002 <span class="comment">//&amp;</span>
00003 <span class="comment">//&amp; Copyright (C) 2004 HP-GCC Team</span>
00004 <span class="comment">//&amp;</span>
00005 <span class="comment">//&amp; ****************************************************************************</span>
00006 <span class="comment">//&amp;</span>
00007 <span class="comment">//&amp; This file is part of HP-GCC.</span>
00008 <span class="comment">//&amp;</span>
00009 <span class="comment">//&amp; HP-GCC is free software; you can redistribute it and/or modify</span>
00010 <span class="comment">//&amp; it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment">//&amp; the Free Software Foundation; either version 2, or (at your option)</span>
00012 <span class="comment">//&amp; any later version.</span>
00013 <span class="comment">//&amp; </span>
00014 <span class="comment">//&amp; HP-GCC is distributed in the hope that it will be useful,</span>
00015 <span class="comment">//&amp; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment">//&amp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment">//&amp; GNU General Public License for more details.</span>
00018 <span class="comment">//&amp; </span>
00019 <span class="comment">//&amp; You should have received a copy of the GNU General Public License</span>
00020 <span class="comment">//&amp; along with HP-GCC; see the file COPYING. </span>
00021 <span class="comment">//&amp; </span>
00022 <span class="comment">//&amp; As a special exception, you may use this file as part of a free software</span>
00023 <span class="comment">//&amp; library without restriction.  Specifically, if other files instantiate</span>
00024 <span class="comment">//&amp; templates or use macros or inline functions from this file, or you compile</span>
00025 <span class="comment">//&amp; this file and link it with other files to produce an executable, this</span>
00026 <span class="comment">//&amp; file does not by itself cause the resulting executable to be covered by</span>
00027 <span class="comment">//&amp; the GNU General Public License.  This exception does not however</span>
00028 <span class="comment">//&amp; invalidate any other reasons why the executable file might be covered by</span>
00029 <span class="comment">//&amp; the GNU General Public License.</span>
00030 <span class="comment">//&amp;</span>
00031 <span class="comment">//&amp; ****************************************************************************</span>
00032 
<a name="l00067"></a><a class="code" href="ggl_8h.html#a0">00067</a> <span class="preprocessor">#define STATEBUFSIZE ((11+6)*4)</span>
00068 <span class="preprocessor"></span>
<a name="l00072"></a><a class="code" href="ggl_8h.html#a1">00072</a> <span class="preprocessor">#define LCD_H 80</span>
00073 <span class="preprocessor"></span>
<a name="l00077"></a><a class="code" href="ggl_8h.html#a2">00077</a> <span class="preprocessor">#define LCD_W 160</span>
00078 <span class="preprocessor"></span>
<a name="l00087"></a><a class="code" href="ggl_8h.html#a3">00087</a> <span class="preprocessor">#define SCREENBUFSIZE ((LCD_W&gt;&gt;2)*(LCD_H)*2)</span>
00088 <span class="preprocessor"></span>
00089 <span class="comment">// data types/structures</span>
00090 
00091 <span class="comment">// surface used for bitblt operations</span>
00092 <span class="comment">// notes:</span>
00093 <span class="comment">// a surface is infinite in both width and height, there are no memory limits</span>
00094 <span class="comment">// .addr must be a word aligned address</span>
00095 <span class="comment">// .width is used only to find a new scanline, and can be changed at will</span>
00096 <span class="comment">//        the width is given in pixels and it can be arbitrary (no alignement needed)</span>
00097 <span class="comment">// for normal drawing primitives, (0,0) is the word-aligned address pointed by .addr,</span>
00098 <span class="comment">// disregarding of the values in .x and .y</span>
00099 <span class="comment">// for bitblt operations, .x and .y give the origin (top-left corner) of the region to use</span>
00100 <span class="comment">// the surface is nibble-aligned, so a 1 pixel wide surface will contain 8</span>
00101 <span class="comment">// rows of pixels per word</span>
00102 
<a name="l00112"></a><a class="code" href="structgglsurface.html">00112</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00113"></a><a class="code" href="structgglsurface.html#m0">00113</a>         <span class="keywordtype">int</span> *addr;  
<a name="l00114"></a><a class="code" href="structgglsurface.html#m1">00114</a>         <span class="keywordtype">int</span> width;  
<a name="l00115"></a><a class="code" href="structgglsurface.html#m3">00115</a>         <span class="keywordtype">int</span> x,y;    
00116 } <a class="code" href="structgglsurface.html">gglsurface</a>;
00117 
<a name="l00138"></a><a class="code" href="ggl_8h.html#a5">00138</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> int (*<a class="code" href="ggl_8h.html#a5">gglfilter</a>)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pixels,<span class="keywordtype">int</span> param);
00139 
<a name="l00159"></a><a class="code" href="ggl_8h.html#a6">00159</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> int (*<a class="code" href="ggl_8h.html#a6">ggloperator</a>)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dest,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> source,<span class="keywordtype">int</span> param);
00160 
00161 
00162 <span class="comment">// general routines</span>
00163 
00175 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a7">ggl_initscr</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf);      <span class="comment">// allocate screen buffer</span>
00176 
00188 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a8">ggl_gethpgscreen</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf);
00189 
00202 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a9">ggl_setmode</a>(<span class="keywordtype">int</span> *framebuf);
00203 
00224 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a10">ggl_save</a>(<span class="keywordtype">int</span> *buf); <span class="comment">// save LCD controller state</span>
00225 
00244 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a11">ggl_restore</a>(<span class="keywordtype">int</span> *buf);     <span class="comment">// restore saved LCD state</span>
00245 
00246 <span class="comment">/*</span>
00247 <span class="comment"> * \brief Causes a different GGL surface to be displayed.</span>
00248 <span class="comment"> *</span>
00249 <span class="comment"> * This function allows the use of several GGL surfaces as the main screen</span>
00250 <span class="comment"> * in an application. It causes the LCD controller to begin displaying a</span>
00251 <span class="comment"> * different screen.  No VSYNC is performed, so some tearing is possible </span>
00252 <span class="comment"> * unless external VSYNC is checked before calling this function.</span>
00253 <span class="comment"> *</span>
00254 <span class="comment"> * This function should be used by applications that use GGL exclusively.  If</span>
00255 <span class="comment"> * HPG is in use, the application should use hpg_flip to accomplish page</span>
00256 <span class="comment"> * flipping.</span>
00257 <span class="comment"> *</span>
00258 <span class="comment"> * \param framebuf A pointer to the new LCD screen's frame buffer.  This is</span>
00259 <span class="comment"> *                 generally found in the gglsurface::addr field of a</span>
00260 <span class="comment"> *                 ::gglsurface.</span>
00261 <span class="comment"> */</span>
00262 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a12">ggl_show</a>(<span class="keywordtype">int</span> *buffer);     <span class="comment">// display buffer, no vertical sync</span>
00263 
00264 <span class="comment">// drawing primitives</span>
00265 <span class="comment">// general pixel set/read routines</span>
00266 
00281 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a13">ggl_pltnib</a>(<span class="keywordtype">int</span> *buff,<span class="keywordtype">int</span> off,<span class="keywordtype">int</span> color);   <span class="comment">// poke a pixel (off in nibbles)</span>
00282 
00298 <span class="keywordtype">int</span>  <a class="code" href="ggl_8h.html#a14">ggl_getnib</a>(<span class="keywordtype">int</span> *buff,<span class="keywordtype">int</span> off);                             <span class="comment">// peek a pixel (off in nibbles)</span>
00299 
00300 <span class="comment">// general drawing primitives</span>
00301 
00302 <span class="comment">// note: the argument color is a 32-bit value containing a different</span>
00303 <span class="comment">//       color for each pixel. For solid colors, set color to contain the same value</span>
00304 <span class="comment">//       on every nibble (for color 8, color=0x88888888)</span>
00305 <span class="comment">//       or call ggl_mkcolor for that purpose</span>
00306 
00325 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a15">ggl_hline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> y,<span class="keywordtype">int</span> xl,<span class="keywordtype">int</span> xr, <span class="keywordtype">int</span> color); <span class="comment">// fast low-level horizontal line</span>
00326 
00346 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a16">ggl_vline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x,<span class="keywordtype">int</span> yt,<span class="keywordtype">int</span> yb, <span class="keywordtype">int</span> color); <span class="comment">// fast low-level vertical line</span>
00347 
00369 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a17">ggl_rect</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2,<span class="keywordtype">int</span> color); <span class="comment">// low-level rectangle</span>
00370 
00390 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a18">ggl_rectp</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2,<span class="keywordtype">int</span> *color); <span class="comment">// low-level rectangle with 8x8 pattern</span>
00391 
00392 <span class="comment">// rectangle blt</span>
00393 <span class="comment">// note: see gglsurface above for complete understanding of the behavior of these routines</span>
00394 <span class="comment">// ggl_bitblt loops from top to bottom</span>
00395 
00416 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a19">ggl_bitblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy a rectangular region</span>
00417 
00418 <span class="comment">// ggl_revblt loops from bottom to top, for overlapping zones</span>
00438 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a20">ggl_revblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy a rectangular region, reverse loop</span>
00439 <span class="comment">// ggl_ovlblt chooses to use normal/reverse loop based on the addresses</span>
00440 <span class="comment">// use it when the direcction of movement is unknown</span>
00460 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a21">ggl_ovlblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy overlapped regions</span>
00461 <span class="comment">// ggl_bitbltmask behaves exactly as ggl_bitblt but using tcol as a transparent color</span>
00462 
00463 
<a name="l00486"></a><a class="code" href="ggl_8h.html#a4">00486</a> <span class="preprocessor">#define ggl_bitbltmask(dest,src,width,height,tcol)  ggl_bitbltoper(dest,src,width,height,tcol,&amp;ggl_opmask)</span>
00487 <span class="preprocessor"></span>
00488 
00489 <span class="comment">// rectangle scrolling routines</span>
00490 <span class="comment">// dest contains the surface to scroll, and width and height define the rectangle</span>
00491 <span class="comment">// the area that needs to be redrawn after the scroll is not erased or modified by these routines </span>
00509 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a22">ggl_scrollup</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels up</span>
00528 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a23">ggl_scrolldn</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels dn</span>
00529 
00547 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a24">ggl_scrolllf</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels left</span>
00565 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a25">ggl_scrollrt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels right</span>
00566 
00567 <span class="comment">// custom filters and operators</span>
00568 
00569 <span class="comment">// bitmap filtering routine</span>
00588 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a26">ggl_filter</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> param, <a class="code" href="ggl_8h.html#a5">gglfilter</a> filterfunc);
00589 
00590 <span class="comment">// bitblt operator routine</span>
00612 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a27">ggl_bitbltoper</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,<span class="keywordtype">int</span> param,<a class="code" href="ggl_8h.html#a6">ggloperator</a> fop);
00613 
00614 <span class="comment">// predefined filters and operators</span>
00615 
00616 <span class="comment">// filters (unary operators)</span>
00617 <span class="comment">// ligthens an image by subtracting param from all pixels</span>
00618 
00631 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a28">ggl_fltlighten</a>(<span class="keywordtype">unsigned</span> word,<span class="keywordtype">int</span> param);
00632 <span class="comment">// darkens an image by adding param to all pixels</span>
00633 
00646 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a29">ggl_fltdarken</a>(<span class="keywordtype">unsigned</span> word,<span class="keywordtype">int</span> param);
00647 
00648 <span class="comment">// operators (between two surfaces)</span>
00649 <span class="comment">// standard mask, tcolor in src is considered transparent</span>
00650 
00651 
00666 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a30">ggl_opmask</a>(<span class="keywordtype">unsigned</span> dest,<span class="keywordtype">unsigned</span> src,<span class="keywordtype">int</span> tcolor);
00667 <span class="comment">// transparency blend, weight is 0 = src is opaque, 16 = src is fully transparent</span>
00668 
00684 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a31">ggl_optransp</a>(<span class="keywordtype">unsigned</span> dest,<span class="keywordtype">unsigned</span> src,<span class="keywordtype">int</span> weight);
00685 
00686 
00687 
00688 
00689 <span class="comment">// miscellaneous</span>
00690 
00691 <span class="comment">// ggl_mkcolor repeats the same color on every nibble</span>
00692 <span class="comment">// ggl_mkcolor(2) will return 0x22222222</span>
00702 <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="ggl_8h.html#a32">ggl_mkcolor</a>(<span class="keywordtype">int</span> color); <span class="comment">// solid color generator</span>
00703 
00704 <span class="comment">// ggl_mkcolor32 creates virtual 32-colors by using 8x8 patterns</span>
00705 <span class="comment">// col32 is a value from 0 to 30, being 30=black, 0=white</span>
00706 <span class="comment">// note: the user is responsible to provide a valid int[8] buffer in the</span>
00707 <span class="comment">// pattern argument</span>
00721 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a33">ggl_mkcolor32</a>(<span class="keywordtype">int</span> col32, <span class="keywordtype">int</span> *pattern);    <span class="comment">// 50% dither pattern generator for 31 colors</span>
00722         
00723 <span class="comment">// ANTIALIAS INITIALIZATION</span>
00724 
00725 <span class="comment">// ggl_initaline initializes tables needed for antialiased lines</span>
00735 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a34">ggl_initaline</a>();
00736 
00737 <span class="comment">// for antialiased lines, call first ggl_initaline and call ggl_endaline for cleanup</span>
00738 <span class="comment">// notice that ggl_init/ggl_exit do NOT call ggl_initaline</span>
00739 <span class="comment">// anitaliased lines are always 3 pixels wide</span>
00755 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a35">ggl_aline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2);    <span class="comment">// ANTIALIASED LINES</span>
00756 
00757 <span class="comment">// ggl_endaline cleans up the memory allocated by ggl_initaline</span>
00767 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a36">ggl_endaline</a>();
</pre></div><hr><address style="align: right;"><small>Generated on Mon Apr 4 22:52:22 2005 for GGL by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
