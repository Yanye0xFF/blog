<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ggl.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ggl.h File Reference</h1>Extended grayscale graphics routines for HP calculators. 
<a href="#_details">More...</a>
<p>

<p>
<a href="ggl_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structgglsurface.html">gglsurface</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A surface (bitmap) that can be drawn upon using GGL.</em> <a href="structgglsurface.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a0">STATEBUFSIZE</a>&nbsp;&nbsp;&nbsp;((11+6)*4)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The minimum number of bytes for a state buffer.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a1">LCD_H</a>&nbsp;&nbsp;&nbsp;80</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Height of the screen, in pixels.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a2">LCD_W</a>&nbsp;&nbsp;&nbsp;160</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Width of the screen, in pixels.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a3">SCREENBUFSIZE</a>&nbsp;&nbsp;&nbsp;((LCD_W&gt;&gt;2)*(LCD_H)*2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Number of bytes in the screen buffer.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a4">ggl_bitbltmask</a>(dest, src, width, height, tcol)&nbsp;&nbsp;&nbsp;ggl_bitbltoper(dest,src,width,height,tcol,&amp;ggl_opmask)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies a rectangular surface with mask.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned int(*&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a5">gglfilter</a> )(unsigned int pixels, int param)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A filter for pixels being drawn to a surface.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned int(*&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a6">ggloperator</a> )(unsigned int dest, unsigned int source, int param)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>An operator for pixels being drawn to a surface.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a7">ggl_initscr</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Prepares to draw on the LCD screen with GGL.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a8">ggl_gethpgscreen</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Prepares to draw on the LCD screen with GGL and HPG.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a9">ggl_setmode</a> (int *framebuf)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sets a 16-color display mode.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a10">ggl_save</a> (int *buf)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Saves the state of the LCD controller.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a11">ggl_restore</a> (int *buf)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Restores the state of the LCD controller.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a12">ggl_show</a> (int *buffer)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a13">ggl_pltnib</a> (int *buff, int off, int color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pokes a color into a specific pixel of a surface.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a14">ggl_getnib</a> (int *buff, int off)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Peeks a color from a specific pixel of a surface.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a15">ggl_hline</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf, int y, int xl, int xr, int color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws a horizontal line on a surface.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a16">ggl_vline</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf, int x, int yt, int yb, int color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws a vertical line on a surface.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a17">ggl_rect</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf, int x1, int y1, int x2, int y2, int color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws a rectangle on a surface.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a18">ggl_rectp</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf, int x1, int y1, int x2, int y2, int *color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draws a rectangle on a surface with a 2D pattern.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a19">ggl_bitblt</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, <a class="el" href="structgglsurface.html">gglsurface</a> *src, int width, int height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies a rectangular surface. Forward direction.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a20">ggl_revblt</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, <a class="el" href="structgglsurface.html">gglsurface</a> *src, int width, int height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies a rectangular surface. Reverse direction.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a21">ggl_ovlblt</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, <a class="el" href="structgglsurface.html">gglsurface</a> *src, int width, int height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies a rectangular surface. Safe to use when areas overlap.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a22">ggl_scrollup</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, int width, int height, int npixels)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Scroll a surface up.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a23">ggl_scrolldn</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, int width, int height, int npixels)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Scroll a surface down.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a24">ggl_scrolllf</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, int width, int height, int npixels)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Scroll a surface left.</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a25">ggl_scrollrt</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, int width, int height, int npixels)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Scroll a surface right.</em> <a href="#a25"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a26">ggl_filter</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, int width, int height, int param, <a class="el" href="ggl_8h.html#a5">gglfilter</a> filterfunc)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Applies a filter to a surface.</em> <a href="#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a27">ggl_bitbltoper</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *dest, <a class="el" href="structgglsurface.html">gglsurface</a> *src, int width, int height, int param, <a class="el" href="ggl_8h.html#a6">ggloperator</a> fop)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Applies a binary operator to a surface.</em> <a href="#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a28">ggl_fltlighten</a> (unsigned word, int param)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lightens an image.</em> <a href="#a28"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a29">ggl_fltdarken</a> (unsigned word, int param)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Darkens an image.</em> <a href="#a29"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a30">ggl_opmask</a> (unsigned dest, unsigned src, int tcolor)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Mask operator.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a31">ggl_optransp</a> (unsigned dest, unsigned src, int weight)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Transparency blend operator.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a32">ggl_mkcolor</a> (int color)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Solid color word generator.</em> <a href="#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a33">ggl_mkcolor32</a> (int col32, int *pattern)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>30-colors dither pattern generator.</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a34">ggl_initaline</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Antialiased lines initialization.</em> <a href="#a34"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a35">ggl_aline</a> (<a class="el" href="structgglsurface.html">gglsurface</a> *srf, int x1, int y1, int x2, int y2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Draw antialiased line.</em> <a href="#a35"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ggl_8h.html#a36">ggl_endaline</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Antialiased lines cleanup.</em> <a href="#a36"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Extended grayscale graphics routines for HP calculators.
<p>

<p>

<p>
Definition in file <a class="el" href="ggl_8h-source.html">ggl.h</a>.<hr><h2>Define Documentation</h2>
<a name="a4" doxytag="ggl.h::ggl_bitbltmask"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ggl_bitbltmask</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">dest,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>src,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>width,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>height,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>tcol&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;ggl_bitbltoper(dest,src,width,height,tcol,&amp;ggl_opmask)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies a rectangular surface with mask.
<p>
Performs a bitblit copy operation where the given color is considered transparent, thus not affecting the background color. The direction of the memory movement is from top to bottom. Note: This is a macro that calls ggl_bitbltoper with the proper operator.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be copied at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
The source surface. The region to copy will start at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to copy. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to copy. </td></tr>
<tr><td valign=top><em>tcol</em>&nbsp;</td><td>
Transparent color. Color in the source surface to be considered as transparent (between 0 and 15).</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a19">ggl_bitblt</a> , <a class="el" href="ggl_8h.html#a27">ggl_bitbltoper</a> </dl>
<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00486">486</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="ggl.h::LCD_H"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LCD_H&nbsp;&nbsp;&nbsp;80
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Height of the screen, in pixels.
<p>

<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00072">72</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="ggl.h::LCD_W"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LCD_W&nbsp;&nbsp;&nbsp;160
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Width of the screen, in pixels.
<p>

<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00077">77</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="ggl.h::SCREENBUFSIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCREENBUFSIZE&nbsp;&nbsp;&nbsp;((LCD_W&gt;&gt;2)*(LCD_H)*2)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Number of bytes in the screen buffer.
<p>
This constant provides the size in bytes of the screen buffer, allowing  the use of standard routines like memset to clear the screen, memcpy to copy it elsewhere, and so forth. 
<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00087">87</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="ggl.h::STATEBUFSIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define STATEBUFSIZE&nbsp;&nbsp;&nbsp;((11+6)*4)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The minimum number of bytes for a state buffer.
<p>
Save buffers, which are allocated and supplied to GGL by the application for use by <a class="el" href="ggl_8h.html#a10">ggl_save</a> and <a class="el" href="ggl_8h.html#a11">ggl_restore</a>, need to be at least this size to prevent undefined (but probably bad) behavior from occurring.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a10">ggl_save</a> , <a class="el" href="ggl_8h.html#a11">ggl_restore</a> </dl>
<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00067">67</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a5" doxytag="ggl.h::gglfilter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned int(* gglfilter)(unsigned int pixels,int param)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A filter for pixels being drawn to a surface.
<p>
A filter is a unary operation (uses one argument) that is applied to colors being drawn to a screen. Filters are very flexible and can be used for a wide variety of drawing purposes, including color modification and texturing. However, they lack the ability to combine colors with those already on the surface. The function takes as arguments a word containing 8 pixels and a parameter defined by the user. A custom filter should process the 8 pixels, using the parameter if needed, and return a word containing the modified 8 pixels. Packs of 8 pixels are processed at the same time for efficiency reasons. Examples of simple filter operations are to 'darken' or 'lighten' an image. A more complex filter can be written for 'color replace' for example.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a29">ggl_fltdarken</a> , <a class="el" href="ggl_8h.html#a28">ggl_fltlighten</a> , ggloperator </dl>
<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00138">138</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="ggl.h::ggloperator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned int(* ggloperator)(unsigned int dest,unsigned int source,int param)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An operator for pixels being drawn to a surface.
<p>
An operator is a binary operation(using two values) that is applied to colors being drawn to a screen. Operators can be used to implement a great variety of features, including either partial or complete transparency. Operators are more powerful than filters, but at a slightly higher  performance cost. The function takes a word containing 8 pixels from the source surface, a word conatining the corresponding 8 pixels from the destination surface, and an arbitrary parameter. Packs of 8 pixels are processed at the same time for efficiency reasons. The function should return a word containing the 8 pixels resulting from the operation performed.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a30">ggl_opmask</a> , <a class="el" href="ggl_8h.html#a31">ggl_optransp</a> , gglfilter </dl>
<p>
Definition at line <a class="el" href="ggl_8h-source.html#l00159">159</a> of file <a class="el" href="ggl_8h-source.html">ggl.h</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a35" doxytag="ggl.h::ggl_aline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_aline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draw antialiased line.
<p>
Draws a 3-pixel wide line with soft borders. Line is black on white. Call ggl_initaline before using this function.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
Surface to draw onto. </td></tr>
<tr><td valign=top><em>x1</em>&nbsp;</td><td>
X coordinate, origin of the line </td></tr>
<tr><td valign=top><em>y1</em>&nbsp;</td><td>
Y coordinate, origin of the line </td></tr>
<tr><td valign=top><em>x2</em>&nbsp;</td><td>
X coordinate, end of the line </td></tr>
<tr><td valign=top><em>y2</em>&nbsp;</td><td>
Y coordinate, end of the line</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a34">ggl_initaline</a> , <a class="el" href="ggl_8h.html#a36">ggl_endaline</a> </dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="ggl.h::ggl_bitblt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_bitblt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies a rectangular surface. Forward direction.
<p>
Copies a rectangular area from one surface to another. The direction of memory movement is from top to bottom, so care should be taken if the areas overlap.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be copied at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
The source surface. The region to copy will start at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to copy. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to copy.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a20">ggl_revblt</a> , <a class="el" href="ggl_8h.html#a21">ggl_ovlblt</a> </dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="ggl.h::ggl_bitbltoper"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_bitbltoper </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>param</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="ggl_8h.html#a6">ggloperator</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fop</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a binary operator to a surface.
<p>
Applies a user-defined operator on a specified region of a surface, using a second surface as an argument.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to operate on. The area starts at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
The source surface. The area starts at coordinates x and y given in the proper fields of the <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region. </td></tr>
<tr><td valign=top><em>param</em>&nbsp;</td><td>
A parameter to be passed to the operator. This parameter is defined by each operator function. </td></tr>
<tr><td valign=top><em>filterfunc</em>&nbsp;</td><td>
The operator function to apply.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
ggloperator , <a class="el" href="ggl_8h.html#a26">ggl_filter</a> </dl>    </td>
  </tr>
</table>
<a name="a36" doxytag="ggl.h::ggl_endaline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_endaline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Antialiased lines cleanup.
<p>
Call this function after using antialiased lines. Call ggl_initaline for initialization.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a34">ggl_initaline</a> , <a class="el" href="ggl_8h.html#a35">ggl_aline</a> </dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="ggl.h::ggl_filter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_filter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>param</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="ggl_8h.html#a5">gglfilter</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>filterfunc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a filter to a surface.
<p>
Applies a user-defined filter (unary operator) on a specified region of a surface.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to filter. The area to filter starts at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to filter. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to filter. </td></tr>
<tr><td valign=top><em>param</em>&nbsp;</td><td>
A parameter to be passed to the filter. This parameter is defined by each filter function. </td></tr>
<tr><td valign=top><em>filterfunc</em>&nbsp;</td><td>
The filter function to apply.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
gglfilter , <a class="el" href="ggl_8h.html#a27">ggl_bitbltoper</a> </dl>    </td>
  </tr>
</table>
<a name="a29" doxytag="ggl.h::ggl_fltdarken"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned ggl_fltdarken </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>word</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>param</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Darkens an image.
<p>
This filter darkens an image by adding the parameter to all the pixels. Do NOT call this function. This is a filter function to be passed as argument to ggl_filter.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a26">ggl_filter</a> , gglfilter , <a class="el" href="ggl_8h.html#a28">ggl_fltlighten</a> </dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="ggl.h::ggl_fltlighten"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned ggl_fltlighten </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>word</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>param</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lightens an image.
<p>
This filter lightens an image by subtracting the parameter from all the pixels. Do NOT call this function. This is a filter function to be passed as argument to ggl_filter.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a26">ggl_filter</a> , gglfilter , <a class="el" href="ggl_8h.html#a29">ggl_fltdarken</a> </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="ggl.h::ggl_gethpgscreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_gethpgscreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>srf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepares to draw on the LCD screen with GGL and HPG.
<p>
This routine prepares for GGL drawing onto an HPG surface. It fills in the <a class="el" href="structgglsurface.html">gglsurface</a> structure with appropriate values to draw to HPG's standard screen. This function should be called by HPG applications that wish to make use of GGL. Stand-alone GGL applications should use <a class="el" href="ggl_8h.html#a7">ggl_initscr</a> instead.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
An instance of <a class="el" href="structgglsurface.html">gglsurface</a> to fill in with HPG's screen. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="ggl.h::ggl_getnib"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ggl_getnib </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>off</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peeks a color from a specific pixel of a surface.
<p>
Retrieves the color of the given pixel. The pixel is identified by an offset from the beginning of the frame buffer, which is defined as <code>x</code> <code>+</code> <code>y</code> <code>*</code> <code>width</code> for a given x and y coordinate, where <code>width</code> is the width of the surface to plot to. The calling procedure is  responsible for correctly calculating the offset. This reduces the overhead when pixels are painted in a specific sequence.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buff</em>&nbsp;</td><td>
The address of a surface bitmap (<a class="el" href="structgglsurface.html#m0">gglsurface::addr</a> field). </td></tr>
<tr><td valign=top><em>off</em>&nbsp;</td><td>
The offset (<code>x</code> <code>+</code> <code>width</code> <code>*</code> <code>y)</code>.</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
The color, between 0 and 15. </dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="ggl.h::ggl_hline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_hline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>xl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>xr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>color</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a horizontal line on a surface.
<p>
Draws a horizontal line onto the given surface, in the given color or color pattern.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
The surface to draw onto. </td></tr>
<tr><td valign=top><em>y</em>&nbsp;</td><td>
The Y coordinate of the line. </td></tr>
<tr><td valign=top><em>xl</em>&nbsp;</td><td>
The left-most x coordinate of the line. </td></tr>
<tr><td valign=top><em>xr</em>&nbsp;</td><td>
The right-most x coordinate of the line. </td></tr>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
The color pattern. This is a 32-bit value, containing 8 consecutive pixels worth of color. For solid colors, set the color to contain the same pattern on every nibble (for color 8, use 0x88888888), or call <a class="el" href="ggl_8h.html#a32">ggl_mkcolor</a> for that purpose. The colors in this pattern will be used consecutively in the horizontal direction. Patterns are always 8-pixel aligned, so painting a sequence of lines produces the right pattern. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a34" doxytag="ggl.h::ggl_initaline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_initaline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Antialiased lines initialization.
<p>
Call this function before using antialiased lines. Call ggl_endaline for cleanup procedures when done.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a35">ggl_aline</a> , <a class="el" href="ggl_8h.html#a36">ggl_endaline</a> </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="ggl.h::ggl_initscr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_initscr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>srf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepares to draw on the LCD screen with GGL.
<p>
This routine prepares for GGL drawing onto the LCD screen, by allocating memory for the screen buffer and filling the <a class="el" href="structgglsurface.html">gglsurface</a> structure with the proper width and other parameters. It is used by stand-alone GGL applications; HPG applications that make use of GGL should use <a class="el" href="ggl_8h.html#a8">ggl_gethpgscreen</a> instead.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
An instance of <a class="el" href="structgglsurface.html">gglsurface</a> to fill in with the new surface. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="ggl.h::ggl_mkcolor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ggl_mkcolor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>color</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Solid color word generator.
<p>
Generates a word containing the specified color in every nibble, to be used with the line and rectangle functions.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
Color between 0 and 15. </td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a33">ggl_mkcolor32</a> </dl>    </td>
  </tr>
</table>
<a name="a33" doxytag="ggl.h::ggl_mkcolor32"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_mkcolor32 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>col32</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pattern</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
30-colors dither pattern generator.
<p>
Generates an 8x8 pattern containing the specified color. The color is specified in a 30-colors scale. This function will return the appropriate dither pattern to approximate the color.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>col32</em>&nbsp;</td><td>
Color between 0 and 30, 0 being white and 30 being black. </td></tr>
<tr><td valign=top><em>pattern</em>&nbsp;</td><td>
Pointer to and array of 8 words to be filled with the generated pattern.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a32">ggl_mkcolor</a> </dl>    </td>
  </tr>
</table>
<a name="a30" doxytag="ggl.h::ggl_opmask"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned ggl_opmask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tcolor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask operator.
<p>
This operator copies the source image on the destination. All pixels in the source surface matching the color passed as param are not copied. Do NOT call this function. This is an operator function to be passed as argument to ggl_bitbltoper. The macro ggl_bitbltmask uses this operator.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a27">ggl_bitbltoper</a> , ggloperator , <a class="el" href="ggl_8h.html#a4">ggl_bitbltmask</a> </dl>    </td>
  </tr>
</table>
<a name="a31" doxytag="ggl.h::ggl_optransp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned ggl_optransp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>weight</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transparency blend operator.
<p>
This operator copies the source image on the destination with a uniform transparency, specified by the parameter. When parameter is 0, the source surface is opaque. When param is 16 the source surface is fully transparent. Intermediate values provide different opacities. Do NOT call this function. This is an operator function to be passed as argument to ggl_bitbltoper.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a27">ggl_bitbltoper</a> , ggloperator </dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="ggl.h::ggl_ovlblt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_ovlblt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies a rectangular surface. Safe to use when areas overlap.
<p>
Copies a rectangular area from one surface to another. If the areas overlap, it chooses the appropriate direction and calls ggl_bitblt or ggl_revblt as needed.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be copied at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
The source surface. The region to copy will start at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to copy. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to copy.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a19">ggl_bitblt</a> , <a class="el" href="ggl_8h.html#a20">ggl_revblt</a> </dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="ggl.h::ggl_pltnib"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_pltnib </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>off</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>color</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pokes a color into a specific pixel of a surface.
<p>
Colors the given pixel by the given color. The pixel is identified by an offset from the beginning of the frame buffer, which is defined as <code>x</code> <code>+</code> <code>y</code> <code>*</code> <code>width</code> for a given x and y coordinate, where <code>width</code> is the width of the surface to plot to. The calling procedure is  responsible for correctly calculating the offset. This reduces the overhead when pixels are painted in a specific sequence.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buff</em>&nbsp;</td><td>
The address of a surface bitmap (<a class="el" href="structgglsurface.html#m0">gglsurface::addr</a> field). </td></tr>
<tr><td valign=top><em>off</em>&nbsp;</td><td>
The offset (<code>x</code> <code>+</code> <code>width</code> <code>*</code> <code>y)</code>. </td></tr>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
The color, between 0 and 15. 15=black. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="ggl.h::ggl_rect"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_rect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>color</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a rectangle on a surface.
<p>
Fills in a rectangle onto the given surface, with the given color or color pattern. The color pattern is oriented horizontally, so that the color remains the same in any given column of pixels.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
The surface to draw onto. </td></tr>
<tr><td valign=top><em>x1</em>&nbsp;</td><td>
The X coordinate of the top-left coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>y1</em>&nbsp;</td><td>
The Y coordinate of the top-left coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>x2</em>&nbsp;</td><td>
The X coordinate of the bottom-right coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>y2</em>&nbsp;</td><td>
The Y coordinate of the bottom-right coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
The color pattern. This is a 32-bit value, containing 8 consecutive pixels worth of color. For solid colors, set the color to contain the same pattern on every nibble (for color 8, use 0x88888888), or call <a class="el" href="ggl_8h.html#a32">ggl_mkcolor</a> for that purpose. The colors in this pattern will be used consecutively in the horizontal direction. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="ggl.h::ggl_rectp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_rectp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>color</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a rectangle on a surface with a 2D pattern.
<p>
Fills in a rectangle onto the given surface, with the given color or color pattern. The color pattern is 8x8 pixels in size, and is repeated both horizontally and vertically.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
The surface to draw onto. </td></tr>
<tr><td valign=top><em>x1</em>&nbsp;</td><td>
The X coordinate of the top-left coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>y1</em>&nbsp;</td><td>
The Y coordinate of the top-left coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>x2</em>&nbsp;</td><td>
The X coordinate of the bottom-right coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>y2</em>&nbsp;</td><td>
The Y coordinate of the bottom-right coordinate of the rectangle. </td></tr>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
The color pattern. This is an array of 8 32-bit values, each containing 8 consecutive pixels worth of color for a single line. The result is an 8x8 color pattern that is used to draw to the screen. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="ggl.h::ggl_restore"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_restore </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restores the state of the LCD controller.
<p>
Calling this function results in the current state of the LCD controller being restored from the given buffer. The buffer should have been filled in earlier by a call to <a class="el" href="ggl_8h.html#a10">ggl_save</a>. Warning: A buffer with invalid or corrupted data might cause unexpected results, including possible damage to the LCD.
<p>
If HPG is in use, the application should use hpg_cleanup when finished to restore the LCD controller to a known state. It is dangerous to make changes to the LCD controller state while HPG is operating. However, it is safe to use ggl_save before initializing HPG and use  ggl_restore after hpg_cleanup has returned.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buf</em>&nbsp;</td><td>
A flat buffer, containing data stored by ggl_save. </td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a10">ggl_save</a> </dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="ggl.h::ggl_revblt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_revblt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies a rectangular surface. Reverse direction.
<p>
Copies a rectangular area from one surface to another. The direction of memory movement is from bottom to top, so care should be taken if the areas overlap.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be copied at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
The source surface. The region to copy will start at the coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to copy. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to copy.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a19">ggl_bitblt</a> , <a class="el" href="ggl_8h.html#a21">ggl_ovlblt</a> </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="ggl.h::ggl_save"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_save </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the state of the LCD controller.
<p>
Calling this function results in the current state of the LCD controller being stored in the given buffer. The saved state can be restored by passing the same buffer to <a class="el" href="ggl_8h.html#a11">ggl_restore</a>. This function can be used when it is important to restore the LCD controller to the exact previous state. For example, if a program sets the LCD in a non-standard (or unknown state, like when using hardware scrolling, and a routine needs to use the LCD, it can save the state and restore it later using ggl_save and ggl_restore.
<p>
If HPG is in use, the application should use hpg_cleanup when finished to restore the LCD controller to a known state. It is dangerous to make changes to the LCD controller state while HPG is operating. However, it is safe to use ggl_save before initializing HPG and use  ggl_restore after hpg_cleanup has returned.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buf</em>&nbsp;</td><td>
A flat buffer, with a size of at least <a class="el" href="ggl_8h.html#a0">STATEBUFSIZE</a> bytes. </td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a11">ggl_restore</a> </dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="ggl.h::ggl_scrolldn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_scrolldn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>npixels</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scroll a surface down.
<p>
Scrolls down a surface by the specified number of pixels. The unveiled area is not cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be scrolled at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>npixels</em>&nbsp;</td><td>
Number of pixels to scroll.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a22">ggl_scrollup</a> , <a class="el" href="ggl_8h.html#a24">ggl_scrolllf</a> , <a class="el" href="ggl_8h.html#a25">ggl_scrollrt</a> </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="ggl.h::ggl_scrolllf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_scrolllf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>npixels</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scroll a surface left.
<p>
Scrolls left a surface by the specified number of pixels. The unveiled area is not cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be scrolled at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>npixels</em>&nbsp;</td><td>
Number of pixels to scroll.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a22">ggl_scrollup</a> , <a class="el" href="ggl_8h.html#a23">ggl_scrolldn</a> , <a class="el" href="ggl_8h.html#a25">ggl_scrollrt</a> </dl>    </td>
  </tr>
</table>
<a name="a25" doxytag="ggl.h::ggl_scrollrt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_scrollrt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>npixels</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scroll a surface right.
<p>
Scrolls right a surface by the specified number of pixels. The unveiled area is not cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be scrolled at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>npixels</em>&nbsp;</td><td>
Number of pixels to scroll.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a22">ggl_scrollup</a> , <a class="el" href="ggl_8h.html#a23">ggl_scrolldn</a> , <a class="el" href="ggl_8h.html#a24">ggl_scrolllf</a> </dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="ggl.h::ggl_scrollup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_scrollup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>npixels</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scroll a surface up.
<p>
Scrolls up a surface by the specified number of pixels. The unveiled area is not cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
The surface to draw onto. The area will be scrolled at coordinates x and y given in the proper fields of the  <a class="el" href="structgglsurface.html">gglsurface</a> structure. </td></tr>
<tr><td valign=top><em>width</em>&nbsp;</td><td>
The width in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>height</em>&nbsp;</td><td>
The height in pixels of the rectangular region to scroll. </td></tr>
<tr><td valign=top><em>npixels</em>&nbsp;</td><td>
Number of pixels to scroll.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="ggl_8h.html#a23">ggl_scrolldn</a> , <a class="el" href="ggl_8h.html#a24">ggl_scrolllf</a> , <a class="el" href="ggl_8h.html#a25">ggl_scrollrt</a> </dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="ggl.h::ggl_setmode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_setmode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>framebuf</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a 16-color display mode.
<p>
This function actually switches the calculator LCD controller into 16-color grayscale mode, with the given address for a frame buffer. This should be done for stand-alone GGL applications. (HPG applications using GGL should instead use HPG's <code>hpg_set_mode_gray16</code> to perform the same task.)<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>framebuf</em>&nbsp;</td><td>
A pointer to the new LCD screen's frame buffer. This is generally found in the <a class="el" href="structgglsurface.html#m0">gglsurface::addr</a> field of the surface passed to ggl_initscr or ggl_gethpgscreen. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="ggl.h::ggl_show"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_show </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buffer</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a16" doxytag="ggl.h::ggl_vline"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ggl_vline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structgglsurface.html">gglsurface</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>yt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>yb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>color</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a vertical line on a surface.
<p>
Draws a vertical line onto the given surface, in the given color or color pattern.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srf</em>&nbsp;</td><td>
The surface to draw onto. </td></tr>
<tr><td valign=top><em>x</em>&nbsp;</td><td>
The x coordinate of the line. </td></tr>
<tr><td valign=top><em>yt</em>&nbsp;</td><td>
The top-most y coordinate of the line. </td></tr>
<tr><td valign=top><em>yb</em>&nbsp;</td><td>
The bottom-most y coordinate of the line. </td></tr>
<tr><td valign=top><em>color</em>&nbsp;</td><td>
The color pattern. This is a 32-bit value, containing 8 consecutive pixels worth of color. For solid colors, set the color to contain the same pattern on every nibble (for color 8, use 0x88888888), or call <a class="el" href="ggl_8h.html#a32">ggl_mkcolor</a> for that purpose. The colors in this pattern will be used consecutively in the vertical direction, making this different from the use of the color parameter in other GGL functions. Pattern is always 8-pixel aligned. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Mon Apr 4 22:52:22 2005 for GGL by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
